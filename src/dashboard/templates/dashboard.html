<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACMaker Dashboard</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="icon" type="image/svg+xml" href="/img/icon-novo-branco.svg">
</head>

<style>
    /* Modal Styles */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
    }

    .modal-content {
        background-color: #1e1e1e;
        margin: 15% auto;
        padding: 24px;
        border: 1px solid #333;
        border-radius: 12px;
        width: 80%;
        max-width: 500px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        color: #e0e0e0;
        animation: modalFadeIn 0.3s;
    }

    @keyframes modalFadeIn {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .close-btn {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        line-height: 1;
    }

    .close-btn:hover,
    .close-btn:focus {
        color: #fff;
        text-decoration: none;
    }

    .modal-title {
        font-size: 1.5em;
        margin-bottom: 16px;
        color: var(--primary);
        font-weight: 600;
    }

    .modal-text {
        font-size: 1.1em;
        line-height: 1.6;
        color: #ccc;
    }

    /* Language Selector Styles */
    .language-selector {
        position: relative;
        display: inline-block;
        margin-right: 16px;
    }

    .lang-btn {
        background: #2a2a2a;
        border: 1px solid #444;
        color: #e0e0e0;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        transition: all 0.2s ease;
    }

    .lang-btn:hover {
        background: #333;
        border-color: var(--primary);
    }

    .lang-dropdown {
        position: absolute;
        top: 100%;
        right: 0;
        background: #1e1e1e;
        border: 1px solid #444;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 100;
        min-width: 120px;
        overflow: hidden;
    }

    .lang-dropdown.show {
        display: block;
    }

    .lang-option {
        padding: 10px 16px;
        cursor: pointer;
        color: #e0e0e0;
        transition: background 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .lang-option:hover {
        background: #333;
    }

    .lang-option.active {
        background: var(--primary);
        color: #000;
    }

    .lang-flag {
        font-size: 18px;
    }
</style>
</head>

<body>
    <!-- Modal for Strategy Info -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal()">&times;</span>
            <div id="modalTitle" class="modal-title">T√≠tulo</div>
            <div id="modalText" class="modal-text">Texto explicativo...</div>
        </div>
    </div>

    <div class="dashboard">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="logo">
                    <img src="/img/icon-novo-branco.svg" alt="ACMaker">
                    ACMaker Dashboard
                </div>
                <div class="status">
                    <span class="status-dot"></span>
                    {{status}}
                </div>
            </div>
            <div class="header-stats">
                <div class="stat">
                    <div class="stat-label" data-i18n="realized_pnl">P&L Realizado</div>
                    <div class="stat-value {{pnl_class}}">{{realized_pnl}}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Trades</div>
                    <div class="stat-value">{{total_trades}}</div>
                </div>
                <div class="stat">
                    <div class="stat-label" data-i18n="orders">Ordens</div>
                    <div class="stat-value">{{orders_placed}}</div>
                </div>
                <div class="stat">
                    <div class="stat-label" data-i18n="markets">Mercados</div>
                    <div class="stat-value">{{market_count}}</div>
                </div>
                <!-- Language Selector -->
                <div class="language-selector">
                    <button class="lang-btn" onclick="toggleLangDropdown()">
                        <span class="lang-flag" id="currentFlag">üáßüá∑</span>
                        <span id="currentLang">Portugu√™s</span>
                        <span>‚ñº</span>
                    </button>
                    <div class="lang-dropdown" id="langDropdown">
                        <div class="lang-option" onclick="setLanguage('pt')">
                            <span class="lang-flag">üáßüá∑</span>
                            <span>Portugu√™s</span>
                        </div>
                        <div class="lang-option" onclick="setLanguage('en')">
                            <span class="lang-flag">üá∫üá∏</span>
                            <span>English</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sidebar - Market List -->
        <div class="sidebar">
            <div class="sidebar-header" data-i18n="active_markets">Mercados Ativos</div>
            <div class="search-box">
                <input type="text" class="search-input" id="marketSearch" data-i18n-placeholder="search_market"
                    placeholder="Buscar mercado... (ex: STON/IRON)" oninput="filterMarkets()">
            </div>
            <div class="market-list" id="marketList">
                {{ market_list | safe }}
            </div>
        </div>

        <!-- Main Chart Area -->
        <div class="main">
            <div class="chart-header">
                <div class="chart-title">{{ selected_market_display }}</div>
                <div class="chart-actions" id="timeframeButtons">
                    <button class="chart-btn" data-tf="1m">1m</button>
                    <button class="chart-btn" data-tf="3m">3m</button>
                    <button class="chart-btn active" data-tf="5m">5m</button>
                    <button class="chart-btn" data-tf="30m">30m</button>
                    <button class="chart-btn" data-tf="2H">2H</button>
                    <button class="chart-btn" data-tf="6H">6H</button>
                    <button class="chart-btn" data-tf="8H">8H</button>
                    <button class="chart-btn" data-tf="12H">12H</button>
                    <button class="chart-btn" data-tf="1D">1D</button>
                    <button class="chart-btn" data-tf="3D">3D</button>
                    <button class="chart-btn" data-tf="1W">1W</button>
                    <button class="chart-btn" data-tf="1M">1M</button>
                </div>
            </div>
            <div class="chart-container" id="chartContainer">
                <div id="chart"></div>
                <canvas class="chart-canvas" id="drawCanvas"></canvas>
                <div class="drawing-tools">
                    <button class="draw-btn active" id="btnCursor" title="Cursor - Mover Gr√°fico (V)"
                        onclick="setDrawTool('cursor')">‚Üñ</button>
                    <button class="draw-btn" id="btnSelect" title="Selecionar Desenho (S)"
                        onclick="setDrawTool('select')">‚äô</button>
                    <hr class="draw-separator">
                    <button class="draw-btn" id="btnLine" title="Linha de Tend√™ncia (T)"
                        onclick="setDrawTool('line')">‚ï±</button>
                    <button class="draw-btn" id="btnRay" title="Raio (R)" onclick="setDrawTool('ray')">‚Üó</button>
                    <button class="draw-btn" id="btnHline" title="Linha Horizontal (H)"
                        onclick="setDrawTool('hline')">‚îÄ</button>
                    <button class="draw-btn" id="btnVline" title="Linha Vertical"
                        onclick="setDrawTool('vline')">‚îÇ</button>
                    <hr class="draw-separator">
                    <button class="draw-btn" id="btnFib" title="Fibonacci Retracement (F)"
                        onclick="setDrawTool('fib')">ùêπ</button>
                    <button class="draw-btn" id="btnRect" title="Ret√¢ngulo (B)" onclick="setDrawTool('rect')">‚ñ¢</button>
                    <hr class="draw-separator">
                    <button class="draw-btn" id="btnCross" title="Crosshair (C)"
                        onclick="setDrawTool('cross')">+</button>
                    <button class="draw-btn" id="btnClear" title="Limpar Tudo (Del)"
                        onclick="clearDrawings()">üóë</button>
                </div>
            </div>

            <!-- Strategy Panel -->
            <div class="strategy-panel">
                {{ strategy_cards | safe }}
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-title" data-i18n="order_book">Order Book</div>
                <div class="orderbook">
                    {{ orderbook | safe }}
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title" data-i18n="bot_orders">Bot Orders</div>
                <div class="metrics-grid">
                    <div class="metric">
                        <div class="metric-label" data-i18n="buy_order">BUY Order</div>
                        <div class="metric-value" style="color:var(--green)">{{buy_order}}</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label" data-i18n="sell_order">SELL Order</div>
                        <div class="metric-value" style="color:var(--red)">{{sell_order}}</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Spread</div>
                        <div class="metric-value">{{spread}}</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label" data-i18n="position">Posi√ß√£o</div>
                        <div class="metric-value">{{position}}</div>
                    </div>
                </div>
            </div>

            <div class="panel-section" style="flex:1; overflow:hidden;">
                <div class="panel-title" data-i18n="trade_log">Trade Log</div>
                <div class="trade-log">
                    {{ trade_log | safe }}
                </div>
            </div>

            <div class="footer">
                <span><span data-i18n="last_update">√öltima atualiza√ß√£o</span>: {{timestamp}}</span>
                <span id="connectionStatus">üîÑ <span data-i18n="connecting">Conectando...</span></span>
            </div>
        </div>
    </div>

    <script src="/static/js/drawing.js"></script>
    <script>
        // Strategy Explanations
        const strategyInfo = {
            "scarcity": {
                title: "Estrat√©gia de Escassez",
                text: "Ajusta o pre√ßo comprando e vendendo de acordo com o n√≠vel do estoque. Se o estoque est√° cheio, o pre√ßo cai para vender mais r√°pido. Se est√° vazio, o pre√ßo sobe para evitar ficar sem produtos."
            },
            "ticker": {
                title: "Pre√ßo de Mercado (Ticker)",
                text: "Representa o √∫ltimo pre√ßo negociado no mercado BlockyCRAFT real (sem influ√™ncia do bot). √â a refer√™ncia de quanto outros jogadores est√£o pagando no momento."
            },
            "vwap": {
                title: "Pre√ßo M√©dio Ponderado (VWAP)",
                text: "O VWAP (Volume Weighted Average Price) calcula o pre√ßo m√©dio considerando o volume das negocia√ß√µes. D√° uma no√ß√£o melhor da tend√™ncia de pre√ßo real do que apenas o '√∫ltimo trade'."
            },
            "composite": {
                title: "Pre√ßo Composto (Final)",
                text: "√â o veredito final do rob√¥. Esta estrat√©gia combina todas as outras (Escassez, VWAP, Mercado) para decidir o 'Pre√ßo Justo' ideal para colocar as ordens de compra e venda agora."
            }
        };

        function showStrategyInfo(strategy) {
            const info = strategyInfo[strategy.toLowerCase()];
            if (info) {
                document.getElementById('modalTitle').innerText = info.title;
                document.getElementById('modalText').innerText = info.text;
                document.getElementById('infoModal').style.display = "block";
            }
        }

        function closeModal() {
            document.getElementById('infoModal').style.display = "none";
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const modal = document.getElementById('infoModal');
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }

        // Initialize TradingView-style chart
        const chartContainer = document.getElementById('chartContainer');
        const chart = LightweightCharts.createChart(document.getElementById('chart'), {
            width: chartContainer.clientWidth,
            height: chartContainer.clientHeight,
            layout: {
                background: { type: 'solid', color: '#000000' },
                textColor: '#e0e0e0',
            },
            grid: {
                vertLines: { color: '#111111' },
                horzLines: { color: '#111111' },
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
            },
            rightPriceScale: {
                borderColor: '#111111',
            },
            timeScale: {
                borderColor: '#111111',
                timeVisible: true,
            },
        });

        const candleSeries = chart.addCandlestickSeries({
            upColor: '#00ff00',
            downColor: '#ff0000',
            borderUpColor: '#00ff00',
            borderDownColor: '#ff0000',
            wickUpColor: '#00ff00',
            wickDownColor: '#ff0000',
        });

        // Load candle data from server (initial load)
        const serverCandleData = {{ candle_data | safe }};

        // Strategy data from server
        const strategies = {{ strategy_lines | safe }};
        const bidPrice = {{ bid_price }};
        const askPrice = {{ ask_price }};


        // Get current market from URL path (e.g., /dashboard/coal_iron -> coal_iron)
        const pathParts = window.location.pathname.split('/');
        const urlMarket = pathParts[pathParts.length - 1];
        // If URL ends with 'dashboard' (no market specified), use default
        const currentMarket = (urlMarket && urlMarket !== 'dashboard' && urlMarket !== '') ? urlMarket : 'diam_iron';
        console.log('Current market:', currentMarket);

        // Timeframe configurations (matching BlockyCRAFT interface)
        const timeframes = ['1m', '3m', '5m', '30m', '2H', '6H', '8H', '12H', '1D', '3D', '1W', '1M'];
        let currentTimeframe = '5m';
        let isLoadingCandles = false;

        // Fetch real candles from API
        async function fetchRealCandles(market, timeframe) {
            if (isLoadingCandles) return null;
            isLoadingCandles = true;

            try {
                const url = `/api/candles/${market}?tf=${timeframe}`;
                console.log('Fetching candles from:', url);

                const response = await fetch(url);
                if (!response.ok) {
                    console.error('Failed to fetch candles:', response.status);
                    return null;
                }

                const candles = await response.json();
                console.log(`Loaded ${candles.length} real candles for ${market} (${timeframe})`);
                return candles;
            } catch (error) {
                console.error('Error fetching candles:', error);
                return null;
            } finally {
                isLoadingCandles = false;
            }
        }

        // Update chart with new candle data
        async function updateChartCandles(timeframe) {
            const candles = await fetchRealCandles(currentMarket, timeframe);

            if (candles && candles.length > 0) {
                candleSeries.setData(candles);
                console.log('Chart updated with real data');
            } else {
                // No data available - clear the chart (no mock data!)
                console.warn('No data available for this timeframe');
                candleSeries.setData([]);  // Clear the chart
            }
        }

        // =============================================
        // PRICE LINES MANAGEMENT - Always Visible
        // =============================================

        // Persistent line references (created once, updated as needed)
        let strategyLines = {};  // { name: lineReference }
        let bidLine = null;
        let askLine = null;
        let linesInitialized = false;

        // Validate price value
        function isValidPrice(price) {
            return typeof price === 'number' && !isNaN(price) && isFinite(price) && price > 0;
        }

        // Get default price if invalid
        function getValidPrice(price, defaultPrice) {
            return isValidPrice(price) ? price : defaultPrice;
        }

        // Create all price lines (called once on init)
        function initializePriceLines() {
            if (linesInitialized) return;

            const defaultMid = serverCandleData[serverCandleData.length - 1]?.close || 50;

            // Create strategy lines
            const strategyColors = {
                'SCARCITY': '#ff00ff',
                'TICKER': '#00ff00',
                'VWAP': '#00aaff',
                'COMPOSITE': '#ffaa00'
            };

            // Create from server data or use defaults
            if (strategies && strategies.length > 0) {
                strategies.forEach(s => {
                    const validPrice = getValidPrice(s.price, defaultMid);
                    strategyLines[s.name] = candleSeries.createPriceLine({
                        price: validPrice,
                        color: s.color || strategyColors[s.name] || '#ffffff',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: true,
                        title: s.name,
                    });
                });
            } else {
                // Create default strategy lines if none from server
                Object.entries(strategyColors).forEach(([name, color]) => {
                    strategyLines[name] = candleSeries.createPriceLine({
                        price: defaultMid,
                        color: color,
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: true,
                        title: name,
                    });
                });
            }

            // Create BID line
            const validBid = getValidPrice(bidPrice, defaultMid * 0.97);
            bidLine = candleSeries.createPriceLine({
                price: validBid,
                color: '#00ff00',
                lineWidth: 2,
                lineStyle: LightweightCharts.LineStyle.Solid,
                axisLabelVisible: true,
                title: 'BID',
            });

            // Create ASK line
            const validAsk = getValidPrice(askPrice, defaultMid * 1.03);
            askLine = candleSeries.createPriceLine({
                price: validAsk,
                color: '#ff0000',
                lineWidth: 2,
                lineStyle: LightweightCharts.LineStyle.Solid,
                axisLabelVisible: true,
                title: 'ASK',
            });

            linesInitialized = true;
            console.log('Price lines initialized:', Object.keys(strategyLines), 'BID:', validBid, 'ASK:', validAsk);
        }

        // Update line prices (keeps lines visible, just changes price)
        function updateLinePrices() {
            const defaultMid = serverCandleData[serverCandleData.length - 1]?.close || 50;

            // Update strategy lines
            if (strategies && strategies.length > 0) {
                strategies.forEach(s => {
                    if (strategyLines[s.name]) {
                        const validPrice = getValidPrice(s.price, defaultMid);
                        strategyLines[s.name].applyOptions({ price: validPrice });
                    }
                });
            }

            // Update BID/ASK
            if (bidLine) {
                bidLine.applyOptions({ price: getValidPrice(bidPrice, defaultMid * 0.97) });
            }
            if (askLine) {
                askLine.applyOptions({ price: getValidPrice(askPrice, defaultMid * 1.03) });
            }
        }

        // Fetch strategy lines from API and update chart
        async function fetchAndUpdateStrategyLines(market) {
            try {
                const response = await fetch(`/api/strategy/${market}`);
                if (!response.ok) {
                    console.warn('Failed to fetch strategy lines:', response.status);
                    return;
                }

                const data = await response.json();
                const newStrategies = data.strategy_lines || [];
                const mid = data.mid_price || 50;

                // Update each strategy line with new price
                newStrategies.forEach(s => {
                    if (strategyLines[s.name]) {
                        const validPrice = getValidPrice(s.price, mid);
                        strategyLines[s.name].applyOptions({
                            price: validPrice,
                            color: s.color
                        });
                        console.log(`Updated ${s.name} line to ${validPrice}`);
                    }
                });

                // Update BID/ASK based on mid
                const spread = 0.03; // 3% default
                if (bidLine) {
                    bidLine.applyOptions({ price: mid * (1 - spread / 2) });
                }
                if (askLine) {
                    askLine.applyOptions({ price: mid * (1 + spread / 2) });
                }

                console.log('Strategy lines updated from API for', market);
            } catch (error) {
                console.error('Error fetching strategy lines:', error);
            }
        }

        // Initialize chart with server data (already real from API)
        // Server sends 4H candles by default, we use that initially
        candleSeries.setData(serverCandleData);
        console.log('Initial chart loaded with', serverCandleData.length, 'candles from server');

        // Debug: log strategies data
        console.log('Strategies loaded:', strategies);
        console.log('Bid price:', bidPrice, 'Ask price:', askPrice);

        // Initialize price lines AFTER data is set
        initializePriceLines();

        // Resize handler for responsive chart
        new ResizeObserver(() => {
            chart.applyOptions({
                width: chartContainer.clientWidth,
                height: chartContainer.clientHeight
            });
        }).observe(chartContainer);

        // Market search filter
        function filterMarkets() {
            const searchInput = document.getElementById('marketSearch');
            const filter = searchInput.value.toUpperCase().replace('/', '_');
            const marketList = document.getElementById('marketList');
            const items = marketList.getElementsByClassName('market-item');

            for (let i = 0; i < items.length; i++) {
                const marketName = items[i].getAttribute('data-market') ||
                    items[i].querySelector('.market-name').textContent;
                if (marketName.toUpperCase().indexOf(filter) > -1) {
                    items[i].classList.remove('hidden');
                } else {
                    items[i].classList.add('hidden');
                }
            }
        }
        window.filterMarkets = filterMarkets;

        // Timeframe button handlers
        document.getElementById('timeframeButtons').addEventListener('click', async (e) => {
            if (e.target.classList.contains('chart-btn')) {
                const tf = e.target.dataset.tf;
                if (tf === currentTimeframe) return;
                if (isLoadingCandles) return; // Prevent double-click

                document.querySelectorAll('#timeframeButtons .chart-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentTimeframe = tf;

                // Show loading state
                e.target.textContent = '...';

                // Fetch REAL candles from BlockyCRAFT API
                const candles = await fetchRealCandles(currentMarket, tf);

                // Restore button text
                e.target.textContent = tf;

                if (candles && candles.length > 0) {
                    candleSeries.setData(candles);
                    console.log('Timeframe changed to:', tf, '- Loaded', candles.length, 'real candles');
                } else {
                    // No data for this timeframe - clear chart
                    console.warn('No candles available for', tf, '- clearing chart');
                    candleSeries.setData([]);
                }

                // Fetch fresh strategy lines from API to keep them in sync
                await fetchAndUpdateStrategyLines(currentMarket);
            }
        });

        // Initialize drawing tools
        initDrawingTools('drawCanvas', 'chartContainer', currentMarket);

        // ===========================================
        // INTERNATIONALIZATION (i18n) SYSTEM
        // ===========================================
        const translations = {
            pt: {
                // Header
                realized_pnl: "P&L Realizado",
                orders: "Ordens",
                markets: "Mercados",
                // Sidebar
                active_markets: "Mercados Ativos",
                search_market: "Buscar mercado... (ex: STON/IRON)",
                // Bot Orders
                bot_orders: "Ordens do Bot",
                buy_order: "Ordem de COMPRA",
                sell_order: "Ordem de VENDA",
                position: "Posi√ß√£o",
                // Order Book
                order_book: "Livro de Ordens",
                // Trade Log
                trade_log: "Hist√≥rico de Trades",
                no_trades_yet: "Nenhum trade ainda...",
                // Footer
                last_update: "Atualiza√ß√£o",
                auto_refresh_disabled: "Auto-refresh off",
                realtime_connected: "Ao vivo",
                realtime_disconnected: "Desconectado",
                connecting: "Conectando...",
                // Strategy Cards
                confidence: "Confian√ßa",
                waiting_data: "Aguardando dados...",
                // Strategy Info
                scarcity_title: "Escassez",
                scarcity_text: "Ajusta o pre√ßo comprando e vendendo de acordo com o n√≠vel do estoque. Se o estoque est√° cheio, o pre√ßo cai para vender mais r√°pido. Se est√° vazio, o pre√ßo sobe para evitar ficar sem produtos.",
                ticker_title: "Ticker",
                ticker_text: "Representa o √∫ltimo pre√ßo negociado no mercado BlockyCRAFT real (sem influ√™ncia do bot). √â a refer√™ncia de quanto outros jogadores est√£o pagando no momento.",
                vwap_title: "VWAP",
                vwap_text: "O VWAP (Volume Weighted Average Price) calcula o pre√ßo m√©dio considerando o volume das negocia√ß√µes. D√° uma no√ß√£o melhor da tend√™ncia de pre√ßo real do que apenas o '√∫ltimo trade'.",
                composite_title: "Composto",
                composite_text: "√â o veredito final do rob√¥. Esta estrat√©gia combina todas as outras (Escassez, VWAP, Mercado) para decidir o 'Pre√ßo Justo' ideal para colocar as ordens de compra e venda agora."
            },
            en: {
                // Header
                realized_pnl: "Realized P&L",
                orders: "Orders",
                markets: "Markets",
                // Sidebar
                active_markets: "Active Markets",
                search_market: "Search market... (ex: STON/IRON)",
                // Bot Orders
                bot_orders: "Bot Orders",
                buy_order: "BUY Order",
                sell_order: "SELL Order",
                position: "Position",
                // Order Book
                order_book: "Order Book",
                // Trade Log
                trade_log: "Trade Log",
                no_trades_yet: "No trades yet...",
                // Footer
                last_update: "Updated",
                auto_refresh_disabled: "Auto-refresh off",
                realtime_connected: "Live",
                realtime_disconnected: "Disconnected",
                connecting: "Connecting...",
                // Strategy Cards
                confidence: "Confidence",
                waiting_data: "Waiting for data...",
                // Strategy Info
                scarcity_title: "Scarcity",
                scarcity_text: "Adjusts prices based on inventory levels. When stock is full, prices drop to sell faster. When empty, prices rise to avoid running out of products.",
                ticker_title: "Ticker",
                ticker_text: "Represents the last traded price on the real BlockyCRAFT market (without bot influence). It's a reference for what other players are currently paying.",
                vwap_title: "VWAP",
                vwap_text: "VWAP calculates the average price considering trading volume. It gives a better sense of the real price trend than just the 'last trade'.",
                composite_title: "Composite",
                composite_text: "This is the bot's final verdict. This strategy combines all others (Scarcity, VWAP, Market) to decide the optimal 'Fair Price' for placing buy and sell orders."
            }
        };

        // Strategy info with i18n support
        function getStrategyInfo(strategy) {
            const lang = currentLanguage;
            const key = strategy.toLowerCase();
            return {
                title: translations[lang][`${key}_title`] || strategyInfo[key]?.title || strategy,
                text: translations[lang][`${key}_text`] || strategyInfo[key]?.text || ''
            };
        }

        // Auto-detect language from browser, fallback to localStorage or 'pt'
        function detectLanguage() {
            const stored = localStorage.getItem('dashboard_lang');
            if (stored) return stored;

            const browserLang = navigator.language || navigator.userLanguage || '';
            if (browserLang.toLowerCase().startsWith('en')) return 'en';
            return 'pt'; // Default to Portuguese
        }

        let currentLanguage = detectLanguage();

        function toggleLangDropdown() {
            const dropdown = document.getElementById('langDropdown');
            dropdown.classList.toggle('show');
        }

        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('dashboard_lang', lang);
            applyTranslations();
            updateLangButton();
            document.getElementById('langDropdown').classList.remove('show');
        }

        function applyTranslations() {
            const t = translations[currentLanguage];

            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) {
                    el.textContent = t[key];
                }
            });

            // Update placeholders
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (t[key]) {
                    el.placeholder = t[key];
                }
            });

            // Update dropdown active state
            document.querySelectorAll('.lang-option').forEach((opt, i) => {
                opt.classList.remove('active');
                if ((i === 0 && currentLanguage === 'pt') || (i === 1 && currentLanguage === 'en')) {
                    opt.classList.add('active');
                }
            });
        }

        function updateLangButton() {
            const flag = document.getElementById('currentFlag');
            const langText = document.getElementById('currentLang');

            if (currentLanguage === 'en') {
                flag.textContent = 'üá∫üá∏';
                langText.textContent = 'English';
            } else {
                flag.textContent = 'üáßüá∑';
                langText.textContent = 'Portugu√™s';
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const langSelector = document.querySelector('.language-selector');
            if (langSelector && !langSelector.contains(e.target)) {
                document.getElementById('langDropdown').classList.remove('show');
            }
        });

        // Override showStrategyInfo to use i18n
        window.showStrategyInfo = function (strategy) {
            const info = getStrategyInfo(strategy);
            document.getElementById('modalTitle').innerText = info.title;
            document.getElementById('modalText').innerText = info.text;
            document.getElementById('infoModal').style.display = "block";
        };

        // Initialize language on page load
        document.addEventListener('DOMContentLoaded', () => {
            applyTranslations();
            updateLangButton();
        });

        // Also apply immediately in case DOMContentLoaded already fired
        applyTranslations();
        updateLangButton();

        // ===========================================
        // WEBSOCKET FOR REAL-TIME UPDATES
        // ===========================================
        (function initWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws`;
            let ws = null;
            let reconnectAttempts = 0;
            const maxReconnectAttempts = 5;

            function connect() {
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log('üì° WebSocket connected');
                    reconnectAttempts = 0;
                    updateConnectionStatus(true);
                };

                ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleWebSocketMessage(message);
                    } catch (e) {
                        console.error('Error parsing WebSocket message:', e);
                    }
                };

                ws.onclose = () => {
                    console.log('üì° WebSocket disconnected');
                    updateConnectionStatus(false);
                    // Attempt reconnection
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        setTimeout(connect, 3000 * reconnectAttempts);
                    }
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus(false);  // Show disconnected on error
                };
            }

            function handleWebSocketMessage(message) {
                if (message.type === 'stats_update') {
                    updateDashboardStats(message.data);
                }
            }

            function updateDashboardStats(stats) {
                // Update P&L
                const pnlElement = document.querySelector('.stat-value');
                if (pnlElement && stats.realized_pnl !== undefined) {
                    const pnl = stats.realized_pnl;
                    pnlElement.textContent = (pnl >= 0 ? '+' : '') + pnl.toFixed(2);
                    pnlElement.parentElement.className = 'stat-card ' + (pnl >= 0 ? 'positive' : 'negative');
                }

                // Update trades count
                const statCards = document.querySelectorAll('.stat-card');
                statCards.forEach(card => {
                    const label = card.querySelector('.stat-label');
                    const value = card.querySelector('.stat-value');
                    if (label && value) {
                        const labelText = label.textContent.toLowerCase();
                        if (labelText.includes('trade')) {
                            value.textContent = stats.total_trades || 0;
                        } else if (labelText.includes('order')) {
                            value.textContent = stats.orders_placed || 0;
                        }
                    }
                });

                // Update timestamp
                const footer = document.querySelector('.footer span:first-child');
                if (footer) {
                    const now = new Date();
                    const timeStr = now.toTimeString().split(' ')[0];
                    footer.innerHTML = `<span data-i18n="last_update">√öltima atualiza√ß√£o</span>: ${timeStr}`;
                }

                // Update connection status text
                const statusSpan = document.getElementById('connectionStatus');
                if (statusSpan) {
                    statusSpan.innerHTML = 'üü¢ <span data-i18n="realtime_connected">Conectado em tempo real</span>';
                    statusSpan.style.color = '#00ff00';
                }

                // Re-apply translations after updating HTML
                applyTranslations();
            }

            function updateConnectionStatus(connected) {
                const statusSpan = document.getElementById('connectionStatus');
                if (statusSpan) {
                    if (connected) {
                        statusSpan.innerHTML = 'üü¢ <span data-i18n="realtime_connected">Conectado em tempo real</span>';
                        statusSpan.style.color = '#00ff00';
                    } else {
                        statusSpan.innerHTML = 'üî¥ <span data-i18n="realtime_disconnected">Desconectado</span>';
                        statusSpan.style.color = '#ff4444';
                    }
                }
            }

            // Start WebSocket connection
            connect();
        })();
    </script>
</body>

</html>